<!doctype html>
<html class="no-js" lang="en" data-content_root="./">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="CPU Acceleration" href="04-CPU%20Acceleration.html" /><link rel="prev" title="Multiple Dispatch" href="02-Multiple%20Dispatch.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.01.29 -->
        <title>Deep Learning - RLtools Documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="_static/nbsphinx-code-cells.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="_static/overrides.css?v=ca018f06" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: #639694;
  --color-brand-content: #639694;
  --color-admonition-background: orange;
  --sidebar_hide_name: True;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">RLtools Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="_static/banner.svg" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">RLtools Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="01-Containers.html">Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-Multiple%20Dispatch.html">Multiple Dispatch</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Deep Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="04-CPU%20Acceleration.html">CPU Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="05-MNIST%20Classification.html">MNIST Classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-Deep%20Reinforcement%20Learning.html">Deep Reinforcement Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-The%20Loop%20Interface.html">The Loop Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="08-Custom%20Environment.html">Custom Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="09-Python%20Interface.html">Python Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="09-Python%20Interface.html#Embedding-Exported-Checkpoints">Embedding Exported Checkpoints</a></li>
<li class="toctree-l1"><a class="reference internal" href="10-Experiment%20Tracking.html">Experiment Tracking</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="Deep-Learning">
<h1>Deep Learning<a class="headerlink" href="#Deep-Learning" title="Link to this heading">#</a></h1>
<p><a class="reference external" href="https://mybinder.org/v2/gh/rl-tools/documentation/binder?labpath=03-Deep%20Learning.ipynb"><img alt="Binder" src="https://mybinder.org/badge_logo.svg" /></a></p>
<p>Because of the static multiple dispatch paradigm layed out in <a class="reference internal" href="02-Multiple%20Dispatch.html"><span class="doc">Multiple Dispatch</span></a>, we need to first include the primitive operations for the device(s) we are inteding on using such that the algorithms (and datastructures) we later include for deep learning can use them.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;rl_tools/operations/cpu.h&gt;</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;rl_tools/nn/layers/dense/operations_cpu.h&gt;</span>
</pre></div>
</div>
</div>
<p>We set up the environment as described in <a class="reference internal" href="01-Containers.html"><span class="doc">Containers</span></a>:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">rlt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">rl_tools</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">DEVICE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">devices</span><span class="o">::</span><span class="n">DefaultCPU</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">RNG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEVICE</span><span class="o">::</span><span class="n">SPEC</span><span class="o">::</span><span class="n">RANDOM</span><span class="o">::</span><span class="n">ENGINE</span><span class="o">&lt;&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">TI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">DEVICE</span><span class="o">::</span><span class="n">index_t</span><span class="p">;</span>
<span class="n">DEVICE</span><span class="w"> </span><span class="n">device</span><span class="p">;</span>
<span class="n">RNG</span><span class="w"> </span><span class="n">rng</span><span class="p">;</span>
<span class="n">TI</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>As justified by our analysis of the reinforcement learnign for continuous control landscape (in the <a class="reference external" href="https://arxiv.org/abs/2306.03530">paper</a>) in the beginning <strong>RLtools</strong> only supports fully connected neural networks. But we are planning on adding more architectures (especially recurrent neural networks) in the future.</p>
<p>We can instantiate a simple layer by first defining its hyperparameters (which are compile-time <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> and types):</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="n">TI</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">TI</span><span class="w"> </span><span class="n">INPUT_DIM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">TI</span><span class="w"> </span><span class="n">OUTPUT_DIM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">ACTIVATION_FUNCTION</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">activation_functions</span><span class="o">::</span><span class="n">RELU</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>These hyperparameters and other options are combined into a specification type such that it is easier to pass it around and such that we don’t need to write out all hyperparameters and options as template parameters when a function takes the datastructure as an argument:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">LAYER_CONFIG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">layers</span><span class="o">::</span><span class="n">dense</span><span class="o">::</span><span class="n">Configuration</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT_DIM</span><span class="p">,</span><span class="w"> </span><span class="n">ACTIVATION_FUNCTION</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>The data structure of a layer does not only depend on its (previously defined) structure but also on the required capabilities. E.g. if we want to do backward passes, the layer needs to store intermediate activations during the forward pass. Furthermore, the buffers of these intermediate values also depend on the batch size. We decouple the capabilities from the structure specification such that we can easily change the capability of a layer or model (e.g. for checkpointing, where we only want
to save the parts required for inference or changing the batch size).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">CAPABILITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">capability</span><span class="o">::</span><span class="n">Forward</span><span class="o">&lt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>You might have noticed that the <code class="docutils literal notranslate"><span class="pre">LAYER_CONFIG</span></code> does not specify an input dimensionality. This is because the input shapes automatically cascade through models in RLtools, where the input shape of a subsequent layer is determined by the output shape of the preceding layer. This will make more sense once we introduce the <code class="docutils literal notranslate"><span class="pre">Sequential</span></code> model that combines multiple layers later in this document.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">INPUT_SHAPE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">tensor</span><span class="o">::</span><span class="n">Shape</span><span class="o">&lt;</span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_DIM</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Using this specification we can declare an actual layer:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">layers</span><span class="o">::</span><span class="n">dense</span><span class="o">::</span><span class="n">Layer</span><span class="o">&lt;</span><span class="n">LAYER_CONFIG</span><span class="p">,</span><span class="w"> </span><span class="n">CAPABILITY</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_SHAPE</span><span class="o">&gt;</span><span class="w"> </span><span class="n">layer</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>A fully connected neural network consists of layers each implementing:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y = f(Wx + b)\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(x\)</span> is the input (external or from the previous layer), <span class="math notranslate nohighlight">\(W\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are the weight matrix and biases respectively and <span class="math notranslate nohighlight">\(f\)</span> is an element-wise non-linear function. Hence the data structure of a layer should contain at least <span class="math notranslate nohighlight">\(W\)</span> and <span class="math notranslate nohighlight">\(b\)</span>. Because these parameters are containers they need to be allocated:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Now that the memory is allocated we need to initialize it (because it may contain arbitrary values). By default, we use the standard <a class="reference external" href="https://pytorch.org/docs/stable/nn.init.html?highlight=kaiming#torch.nn.init.kaiming_normal_">Kaiming</a> initialization scheme:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">,</span><span class="w"> </span><span class="n">seed</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">init_weights</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>We can print <span class="math notranslate nohighlight">\(W\)</span> and <span class="math notranslate nohighlight">\(b\)</span>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer</span><span class="p">.</span><span class="n">weights</span><span class="p">.</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
   -0.281671    -0.424024     0.385982     0.044419     0.400462
   -0.013641    -0.071225    -0.160517    -0.151753    -0.309090
    0.177868     0.106679    -0.339927    -0.179194    -0.013259
    0.118724     0.108345     0.284631     0.026065     0.163703
   -0.001287     0.012145     0.077634    -0.282246     0.196554
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer</span><span class="p">.</span><span class="n">biases</span><span class="p">.</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
   -0.057248    -0.057849    -0.264170    -0.208556    -0.326842
</pre></div></div>
</div>
<p>Now that the layer is initialized we can run inference using a random input. We first declare and allocate input and output matrices and then randomly initialize the input:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">rlt</span><span class="o">::</span><span class="n">matrix</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_DIM</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">input</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">rlt</span><span class="o">::</span><span class="n">matrix</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT_DIM</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">randn</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
   -0.696818     0.150269    -2.589913    -0.316640    -1.897954
</pre></div></div>
</div>
<p>Now we can evaluate output of the layer:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">decltype</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&lt;</span><span class="n">BATCH_SIZE</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">evaluate</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
    0.000000     0.991368     0.590204     0.000000     0.000000
</pre></div></div>
</div>
<p>Now we are revisiting the capabilities mentioned earlier. For inference storing <span class="math notranslate nohighlight">\(W\)</span> and <span class="math notranslate nohighlight">\(b\)</span> is sufficient but for training we at least need to also store the gradient of the loss <span class="math notranslate nohighlight">\(L\)</span> wrt. <span class="math notranslate nohighlight">\(W\)</span> and <span class="math notranslate nohighlight">\(b\)</span>: <span class="math notranslate nohighlight">\(\frac{\mathrm{d}L}{\mathrm{d}W}\)</span> and <span class="math notranslate nohighlight">\(\frac{\mathrm{d}L}{\mathrm{d}b}\)</span>. Because depending on the optimizer type we might need to store more information per parameter (like the first and second-order moment in the case of
<a class="reference external" href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Adam">Adam</a>), we abstract the storage for the weights and biases using a parameter type (defined under the <code class="docutils literal notranslate"><span class="pre">rl_tools::nn::parameters</span></code> namespace) that can e.b. be <code class="docutils literal notranslate"><span class="pre">Plain</span></code>, <code class="docutils literal notranslate"><span class="pre">Gradient</span></code>, <code class="docutils literal notranslate"><span class="pre">Adam</span></code> or any other type extended by the user. For this illustration we are using <code class="docutils literal notranslate"><span class="pre">Gradient</span></code>:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">PARAMETER_TYPE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">parameters</span><span class="o">::</span><span class="n">Gradient</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">CAPABILITY_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">capability</span><span class="o">::</span><span class="n">Gradient</span><span class="o">&lt;</span><span class="n">PARAMETER_TYPE</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">LAYER_2_CONFIG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">layers</span><span class="o">::</span><span class="n">dense</span><span class="o">::</span><span class="n">Configuration</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT_DIM</span><span class="p">,</span><span class="w"> </span><span class="n">ACTIVATION_FUNCTION</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">layers</span><span class="o">::</span><span class="n">dense</span><span class="o">::</span><span class="n">Layer</span><span class="o">&lt;</span><span class="n">LAYER_2_CONFIG</span><span class="p">,</span><span class="w"> </span><span class="n">CAPABILITY_2</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_SHAPE</span><span class="o">&gt;</span><span class="w"> </span><span class="n">layer_2</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer_2</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"> </span><span class="n">layer_2</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">zero_gradient</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer_2</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Note that by using the <code class="docutils literal notranslate"><span class="pre">rl_tools::nn::capability::Gradient</span></code> capability, the <code class="docutils literal notranslate"><span class="pre">rl_tools::nn::layers::dense::Layer</span></code> datastructure contains the necessary buffers (e.g. for itermediate activations) to support the backpropagation algorithm. Additionally, similar to PyTorch we are setting the gradient to zero because it is accumulated with subsequent backward passes.</p>
<p>Now we can backpropagate the derivative of the loss wrt. the <code class="docutils literal notranslate"><span class="pre">output</span></code> to calculate the derivative of the loss wrt. the <code class="docutils literal notranslate"><span class="pre">input</span></code>. Hence the derivative of the loss wrt. the <code class="docutils literal notranslate"><span class="pre">output</span></code>: <code class="docutils literal notranslate"><span class="pre">d_output</span></code> is actually an input to the <code class="docutils literal notranslate"><span class="pre">rl_tools::backward</span></code> operator. The operator also accumulates the derivative of the loss wrt. the weights and biases in the layer. We first allocate containers for <code class="docutils literal notranslate"><span class="pre">d_input</span></code> and <code class="docutils literal notranslate"><span class="pre">d_output</span></code> and randomly set <code class="docutils literal notranslate"><span class="pre">d_output</span></code> (a hypothetical gradient of the input of some
upstream layers)</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">rlt</span><span class="o">::</span><span class="n">matrix</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT_DIM</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">d_output</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">rlt</span><span class="o">::</span><span class="n">matrix</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_DIM</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">d_input</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">d_input</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">d_output</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">randn</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">d_output</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Now we execute the backpropagation and display the gradient of the loss wrt. the input:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">forward</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer_2</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Output (should be identical to layer_1): &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer_2</span><span class="p">.</span><span class="n">output</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">backward_full</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer_2</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">d_output</span><span class="p">,</span><span class="w"> </span><span class="n">d_input</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Derivative with respect to the input: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">d_input</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Output (should be identical to layer_1):
    0.000000     0.991368     0.590204     0.000000     0.000000
Derivative with respect to the input:
    0.010383     0.067850     0.162538     0.151305     0.302343
</pre></div></div>
</div>
<p>This also accumulates the gradient in the weights and biases:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer_2</span><span class="p">.</span><span class="n">weights</span><span class="p">.</span><span class="n">gradient</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
    0.000000     0.000000     0.000000     0.000000     0.000000
    0.681111    -0.146882     2.531533     0.309502     1.855171
    0.011559    -0.002493     0.042962     0.005252     0.031484
    0.000000     0.000000     0.000000     0.000000     0.000000
    0.000000     0.000000     0.000000     0.000000     0.000000
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer_2</span><span class="p">.</span><span class="n">biases</span><span class="p">.</span><span class="n">gradient</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
    0.000000    -0.977459    -0.016588     0.000000     0.000000
</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">layer_2</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">d_input</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">d_output</span><span class="p">);</span>
</pre></div>
</div>
</div>
<section id="Multilayer-Perceptron-(MLP)">
<h2>Multilayer Perceptron (MLP)<a class="headerlink" href="#Multilayer-Perceptron-(MLP)" title="Link to this heading">#</a></h2>
<p>Until now we showed the behavior of a single, fully-connected layer. <strong>RLtools</strong> contains an <a class="reference external" href="https://en.wikipedia.org/wiki/Multilayer_perceptron">Multilayer Perceptron (MLP)</a> that conveniently integrates an arbitrary number of layers into a single data structure with algorithms to perform forward passes and backpropagation across the whole model. The MLP is locate under the namespace <code class="docutils literal notranslate"><span class="pre">rl_tools::nn_models</span></code> and we include it as well as the operations of the Adam optimizer:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;rl_tools/nn/optimizers/adam/instance/operations_generic.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;rl_tools/nn_models/mlp/operations_generic.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;rl_tools/nn/optimizers/adam/operations_generic.h&gt;</span>
</pre></div>
</div>
</div>
<p>Note that the operations of the (Adam) optimizer are split into <code class="docutils literal notranslate"><span class="pre">instance/operations_generic.h</span></code> and <code class="docutils literal notranslate"><span class="pre">operations_generic.h</span></code>. The former contains operations that use and modify the values that are associated with a particular set of parameters (e.g. <code class="docutils literal notranslate"><span class="pre">weights</span></code> or <code class="docutils literal notranslate"><span class="pre">biases</span></code> of a particular layer). An example is the <code class="docutils literal notranslate"><span class="pre">rl_tools::update</span></code> operation that applies the optimizer and in the case of Adam, updates the first and second order moment based on the gradient and then applies the update rule
to the parameters. Since these parameters can reside in an arbitrary structure (like an MLP or Sequential <code class="docutils literal notranslate"><span class="pre">nn_model</span></code>) the <code class="docutils literal notranslate"><span class="pre">rl_tools::update</span></code> function is called by an operation that knows about this structure (e.g. the <code class="docutils literal notranslate"><span class="pre">rl_tools::update</span></code> of the <code class="docutils literal notranslate"><span class="pre">rl_tools::nn_models::mlp</span></code> in turn calls the update operations of its layers). These instance-associated operations carry out the bulk of the gradient descent step but are necessarily myopic because they don’t know about higher-level structure.
Because optimizers like Adam not only have instance-associated state (like the first and second order moments of the gradient) but also global state like the step counter we also include the global <code class="docutils literal notranslate"><span class="pre">.../adam/operations_generic.h</span></code>.</p>
<p>The order of the include is dictated by the underlying usage, where we call <code class="docutils literal notranslate"><span class="pre">rl_tools::update</span></code> on the optimizer, providing the model. The optimizer then invokes the update of the model, which invokes the update of its submodels/layers which in turn call the update on then parameter instance. For each step in this chain, the next operation should already be included, hence we arrive at the order used in this example.</p>
<p>Next we define the hyperparameters:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="n">TI</span><span class="w"> </span><span class="n">INPUT_DIM_MLP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">TI</span><span class="w"> </span><span class="n">OUTPUT_DIM_MLP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">TI</span><span class="w"> </span><span class="n">NUM_LAYERS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">TI</span><span class="w"> </span><span class="n">HIDDEN_DIM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">ACTIVATION_FUNCTION_MLP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">activation_functions</span><span class="o">::</span><span class="n">RELU</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">OUTPUT_ACTIVATION_FUNCTION_MLP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">activation_functions</span><span class="o">::</span><span class="n">IDENTITY</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Note that the MLP supports architectures with an arbitrary depth but each layer has to have the same dimensionality. This is because the layers are stored in an array and hence all need to have the same type. If we would allow for different hidden dimensions, we would have to give up on having arbitrary depths.</p>
<p>We aggregate the hyperparameters into a specification again (first just for the structure, later for the full network, incorporating the structure):</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">MODEL_CONFIG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn_models</span><span class="o">::</span><span class="n">mlp</span><span class="o">::</span><span class="n">Configuration</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT_DIM_MLP</span><span class="p">,</span><span class="w"> </span><span class="n">NUM_LAYERS</span><span class="p">,</span><span class="w"> </span><span class="n">HIDDEN_DIM</span><span class="p">,</span><span class="w"> </span><span class="n">ACTIVATION_FUNCTION_MLP</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT_ACTIVATION_FUNCTION_MLP</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>We use the default Adam parameters (taken from TensorFlow) and set up the optimizer type using these parameters. Moreover, we create a full network specification for a network that can be trained with Adam which takes the structure specification as an input. Finally we define the full network type:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">PARAMETER_TYPE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">parameters</span><span class="o">::</span><span class="n">Adam</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">CAPABILITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">capability</span><span class="o">::</span><span class="n">Gradient</span><span class="o">&lt;</span><span class="n">PARAMETER_TYPE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">OPTIMIZER_SPEC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">optimizers</span><span class="o">::</span><span class="n">adam</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">OPTIMIZER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">optimizers</span><span class="o">::</span><span class="n">Adam</span><span class="o">&lt;</span><span class="n">OPTIMIZER_SPEC</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">MODEL_TYPE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn_models</span><span class="o">::</span><span class="n">mlp</span><span class="o">::</span><span class="n">NeuralNetwork</span><span class="o">&lt;</span><span class="n">MODEL_CONFIG</span><span class="p">,</span><span class="w"> </span><span class="n">CAPABILITY</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_SHAPE</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Using these type definitions we can now declare the optimizer and the model. All the optimizer state is contained in the <code class="docutils literal notranslate"><span class="pre">PARAMETER_TYPE</span></code> of the model (and an additional <code class="docutils literal notranslate"><span class="pre">age</span></code> integer in the model in the case of Adam). In comparison to PyTorch which stores the optimizer state in the optimizer, we prefer to store the first and second-order moment next to the parameters like it is the case for the gradient anyways (in PyTorch as well). Hence the optimizer is stateless in this case (does not
need to be for user-defined optimizers) and we only need to allocate the model.</p>
<p>The backpropagation algorithm needs to store the intermediate gradients. To save memory we do not add a <code class="docutils literal notranslate"><span class="pre">d_input</span></code> or <code class="docutils literal notranslate"><span class="pre">d_output</span></code> to each layer but rather use a double buffer with the maximum size of the hidden representation needed.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">OPTIMIZER</span><span class="w"> </span><span class="n">optimizer</span><span class="p">;</span>
<span class="n">MODEL_TYPE</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="k">typename</span><span class="w"> </span><span class="nc">MODEL_TYPE</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>We allocate the model and set initialize its weights randomly like in the case for the single layer. We are again zeroing the gradient of all parameters of all layers as well as resetting the optimizer state of all parameters of all layers (e.g. in the case of Adam the first and second order moments are set to zero). Finally we also allocate the buffers</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">optimizer</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">init_weights</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span><span class="w"> </span><span class="c1">// recursively initializes all layers using kaiming initialization</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">zero_gradient</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">);</span><span class="w"> </span><span class="c1">// recursively zeros all gradients in the layers</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">reset_optimizer_state</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">optimizer</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>In this example we showcase an MLP with a five dimensional input and a one dimensional output (remember the <code class="docutils literal notranslate"><span class="pre">OUTPUT_ACTIVATION_FUNCTION_MLP</span></code> is <code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> so it can also output negative values). For these new shapes we declare and allocate the input and output containers:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">rlt</span><span class="o">::</span><span class="n">matrix</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_DIM_MLP</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">d_input_mlp</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">rlt</span><span class="o">::</span><span class="n">matrix</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT_DIM_MLP</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">d_output_mlp</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">d_input_mlp</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">d_output_mlp</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Now, like in the case of the single layer, we can run a forward pass using the input. Because the model is a Adam model (which is a subclass of <code class="docutils literal notranslate"><span class="pre">rlt::nn_models::mlp::NeuralNetworkBackwardGradient</span></code>), it stores the intermediate (and final) outputs.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[28]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">randn</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">forward</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="n">T</span><span class="w"> </span><span class="n">output_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">output_layer</span><span class="p">.</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">output_value</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[28]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0.164536f
</pre></div></div>
</div>
<p>Now imagine we want the output of the model (for this input) to be <span class="math notranslate nohighlight">\(1\)</span>. We calculate the error and feed it back through the model using backpropagation. <code class="docutils literal notranslate"><span class="pre">d_output_mlp</span></code> should be the derivative of the loss function, hence it gives the direction of the output that would increase the loss. Our error is the opposite, if we would move the output into the direction of the error we would come closer to our target value and hence decrease the loss. Because of this, we feed back <code class="docutils literal notranslate"><span class="pre">-error</span></code>. This
procedure also corresponds to using a squared loss because <code class="docutils literal notranslate"><span class="pre">error</span></code> is (up to a constant) the derivative of the squared loss.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[29]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="n">target_output_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">T</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target_output_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">output_value</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">d_output_mlp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">error</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">backward</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">d_output_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>The backward pass populates the gradient in all parameters of the model. Using this gradient we can apply the <code class="docutils literal notranslate"><span class="pre">rlt::step</span></code> operator which updates the first and second order moments of the gradient of all parameters and afterwards applies the Adam update rule to update the parameters:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[30]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">step</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">optimizer</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Now the next forward pass should be closer to the target value:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">forward</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="n">get</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">output_layer</span><span class="p">.</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0.173487f
</pre></div></div>
</div>
<p>Next we will train the network to actually perform a function (not only trying to output a constant value as before). With the following training loop we train it to behave like the <code class="docutils literal notranslate"><span class="pre">rlt::max</span></code> operator which outputs the max of the five inputs. We run the forward and backward pass for <span class="math notranslate nohighlight">\(32\)</span> iterations while accumulating the gradient which effectively leads to a batch size of <span class="math notranslate nohighlight">\(32\)</span></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[32]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">TI</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="n">rlt</span><span class="o">::</span><span class="n">zero_gradient</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">mse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">TI</span><span class="w"> </span><span class="n">batch_i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">batch_i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">batch_i</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="n">rlt</span><span class="o">::</span><span class="n">randn</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="w">        </span><span class="n">rlt</span><span class="o">::</span><span class="n">forward</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">output_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">output_layer</span><span class="p">.</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">target_output_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">);</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target_output_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">output_value</span><span class="p">;</span>
<span class="w">        </span><span class="n">rlt</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">d_output_mlp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">error</span><span class="p">);</span>
<span class="w">        </span><span class="n">rlt</span><span class="o">::</span><span class="n">backward</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">d_output_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span>
<span class="w">        </span><span class="n">mse</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">rlt</span><span class="o">::</span><span class="n">step</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">optimizer</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Squared error: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mse</span><span class="o">/</span><span class="mi">32</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Squared error: 1.261306
Squared error: 0.095473
Squared error: 0.067435
Squared error: 0.022948
Squared error: 0.016156
Squared error: 0.016400
Squared error: 0.017012
Squared error: 0.018638
Squared error: 0.014972
Squared error: 0.030667
</pre></div></div>
</div>
<p>Now we can test the model using some arbitrary input (which should be in the distribution of input values) and the model should output a value close to the maximum of the five input values:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">set</span><span class="p">(</span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.0</span><span class="p">);</span>
<span class="n">set</span><span class="p">(</span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.1</span><span class="p">);</span>
<span class="n">set</span><span class="p">(</span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5</span><span class="p">);</span>
<span class="n">set</span><span class="p">(</span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.4</span><span class="p">);</span>
<span class="n">set</span><span class="p">(</span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.1</span><span class="p">);</span>

<span class="n">rlt</span><span class="o">::</span><span class="n">forward</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">output_layer</span><span class="p">.</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0.531318f
</pre></div></div>
</div>
<p>We can also automatically test it with <span class="math notranslate nohighlight">\(10\)</span> random inputs:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[34]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">TI</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="n">rlt</span><span class="o">::</span><span class="n">randn</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="w">    </span><span class="n">rlt</span><span class="o">::</span><span class="n">forward</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;max: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input_mlp</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; output: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">output_layer</span><span class="p">.</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
max: 1.191373 output: 1.114110
max: 0.104221 output: 0.197573
max: 0.806470 output: 0.812550
max: 0.662122 output: 0.522968
max: 1.077457 output: 0.971939
max: 1.125902 output: 1.106198
max: 0.814696 output: 0.766694
max: 0.518637 output: 0.512569
max: 1.329031 output: 1.429670
max: 1.430187 output: 1.412748
</pre></div></div>
</div>
<p>If the values are not close the model might need some more training iterations.</p>
</section>
<section id="Sequential">
<h2>Sequential<a class="headerlink" href="#Sequential" title="Link to this heading">#</a></h2>
<p>The great advantage of the previously introduced MLP module is that the number of layers is a parameter and hence the architecture can be scaled in width and depth through just two parameters without defining additional types. In many cases more flexibility is required, though, which is why we introduced the Sequential model.</p>
<p>The Sequential model follows the <code class="docutils literal notranslate"><span class="pre">torch.nn.Sequential</span></code> and <code class="docutils literal notranslate"><span class="pre">tensorflow.keras.Sequential</span></code> philosophy. Initially, the Sequential model was created to introduce automatic differentiation to RLtools, since the MLP just has a hard-coded backward pass. With the sequential model the user can just specify a sequence of layers and the forward and backward passes are inferred by the compiler at compile-time, automatically. With the addition of the <code class="docutils literal notranslate"><span class="pre">rlt::Tensor</span></code> interface for arbitrary-dimensional
containers, the role of Sequential model was amplified as we wanted to move away from hard-coded assumptions about dimensions (like batch dimension or sequence dimension) and move to layers adapting depending on the input shape. This “adaptation” of course happens all at compile time to maintain the main philosophy of RLtools that the sizes of all datastructures and loops is known at compile time.</p>
<p>With the move to <code class="docutils literal notranslate"><span class="pre">rlt::Tensor</span></code> the sequential interface adopted semantics that are more similar to <code class="docutils literal notranslate"><span class="pre">tensorflow.keras.Sequential</span></code> where the intermediate shapes are inferred based on the input shape as well. Practically this means, that e.g. dense layers or MLPs (yes, MLPs can be “layers” inside a Sequential model) broadcast over all leading dimensions except the last one. While e.g. recurrent layers like the GRU are consuming (and outputting) the last three dimensions
(<code class="docutils literal notranslate"><span class="pre">SEQUENCE_LENGTH</span> <span class="pre">x</span> <span class="pre">BATCH_SIZE</span> <span class="pre">x</span> <span class="pre">FEATURE_DIM</span></code>).</p>
<p>In the following we build a three-layer, “funnel”-type MLP that we could not build using the <code class="docutils literal notranslate"><span class="pre">MLP</span></code> model because it requires all hidden layers to be of the same dimensionality for the reasons described before. The following specifies the <code class="docutils literal notranslate"><span class="pre">[32,</span> <span class="pre">16,</span> <span class="pre">4]</span></code> MLP with input dim 5:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[35]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;rl_tools/nn_models/sequential/operations_generic.h&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">rlt</span><span class="o">::</span><span class="nn">nn_models</span><span class="o">::</span><span class="nn">sequential</span><span class="p">;</span>

<span class="k">using</span><span class="w"> </span><span class="n">LAYER_1_CONFIG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">layers</span><span class="o">::</span><span class="n">dense</span><span class="o">::</span><span class="n">Configuration</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">activation_functions</span><span class="o">::</span><span class="n">ActivationFunction</span><span class="o">::</span><span class="n">RELU</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">LAYER_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">layers</span><span class="o">::</span><span class="n">dense</span><span class="o">::</span><span class="n">BindConfiguration</span><span class="o">&lt;</span><span class="n">LAYER_1_CONFIG</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">LAYER_2_CONFIG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">layers</span><span class="o">::</span><span class="n">dense</span><span class="o">::</span><span class="n">Configuration</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">activation_functions</span><span class="o">::</span><span class="n">ActivationFunction</span><span class="o">::</span><span class="n">RELU</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">LAYER_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">layers</span><span class="o">::</span><span class="n">dense</span><span class="o">::</span><span class="n">BindConfiguration</span><span class="o">&lt;</span><span class="n">LAYER_2_CONFIG</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">LAYER_3_CONFIG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">layers</span><span class="o">::</span><span class="n">dense</span><span class="o">::</span><span class="n">Configuration</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">activation_functions</span><span class="o">::</span><span class="n">ActivationFunction</span><span class="o">::</span><span class="n">IDENTITY</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">LAYER_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">layers</span><span class="o">::</span><span class="n">dense</span><span class="o">::</span><span class="n">BindConfiguration</span><span class="o">&lt;</span><span class="n">LAYER_3_CONFIG</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">using</span><span class="w"> </span><span class="n">MODULE_CHAIN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Module</span><span class="o">&lt;</span><span class="n">LAYER_1</span><span class="p">,</span><span class="w"> </span><span class="n">Module</span><span class="o">&lt;</span><span class="n">LAYER_2</span><span class="p">,</span><span class="w"> </span><span class="n">Module</span><span class="o">&lt;</span><span class="n">LAYER_3</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>

<span class="k">using</span><span class="w"> </span><span class="n">CAPABILITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">capability</span><span class="o">::</span><span class="n">Forward</span><span class="o">&lt;&gt;</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">TI</span><span class="w"> </span><span class="n">SEQUENCE_LENGTH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">INPUT_SHAPE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">tensor</span><span class="o">::</span><span class="n">Shape</span><span class="o">&lt;</span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">SEQUENCE_LENGTH</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_DIM_MLP</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">using</span><span class="w"> </span><span class="n">SEQUENTIAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Build</span><span class="o">&lt;</span><span class="n">CAPABILITY</span><span class="p">,</span><span class="w"> </span><span class="n">MODULE_CHAIN</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_SHAPE</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>For each layer, we specify a configuration and create a wrapper that binds this configuration. The semantics of this wrapper is that it represents a layer with the given configuration but for any capability or input shape. Technically the wrapper contains a template that is used by the sequential model to actually instantiate the layer with the appropriate capability and input shape.</p>
<p><strong>Capability</strong>: The capability specifies the model’s overarching properties and capabilities. The main capability is if the module (and its constituting layers) only supports forward, backward wrt. to the input or backward including the gradient wrt. the parameters. Additionally the capability is also used to specify if the model should be statically or dynamically allocated. The reason we do not specify these attributes in the configuration is that we might want to use a particular model in
different ways: e.g. having the critics being capable of backward-gradient but the target critic only being capable of forward inference in TD3/SAC. Furthermore, when checkpointing we probably only want to save the parameters and not the gradient and optimizer state. We will showcase this later</p>
<p><strong>Input Shape</strong>: Similar to the capability, we might want to use the model for different input shapes. It is not compelling to change the <code class="docutils literal notranslate"><span class="pre">FEATURE_DIM</span></code> of the input shape, but it is often desirable to change the <code class="docutils literal notranslate"><span class="pre">BATCH_SIZE</span></code> e.g. between RL training and data-collection/exploration.</p>
<p>The API is the same as for other models and layers:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[36]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">SEQUENTIAL</span><span class="w"> </span><span class="n">sequential</span><span class="p">;</span>
<span class="n">SEQUENTIAL</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">sequential_buffer</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">sequential</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">sequential_buffer</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[37]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">init_weights</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">sequential</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[38]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">rlt</span><span class="o">::</span><span class="n">tensor</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">SEQUENTIAL</span><span class="o">::</span><span class="n">INPUT_SHAPE</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">input</span><span class="p">;</span><span class="w"> </span><span class="c1">// note the &quot;false&quot; in the specification making it static/stack-allocated, hence no &quot;malloc&quot; is required</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">rlt</span><span class="o">::</span><span class="n">tensor</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">SEQUENTIAL</span><span class="o">::</span><span class="n">OUTPUT_SHAPE</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">randn</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[39]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">evaluate</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">sequential</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="n">sequential_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
dim[0] = 0:
   2.216075e-01   1.333383e-01   1.274712e-02  -2.575321e-01

</pre></div></div>
</div>
<p>Now if we want to train the model we should have defined the <code class="docutils literal notranslate"><span class="pre">CAPABILITY</span></code> to support backward-gradient. But due to the decoupling from the configuration we can do this in hindsight:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[40]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">PARAMETER_TYPE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">parameters</span><span class="o">::</span><span class="n">Adam</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">NEW_CAPABILITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rlt</span><span class="o">::</span><span class="n">nn</span><span class="o">::</span><span class="n">capability</span><span class="o">::</span><span class="n">Gradient</span><span class="o">&lt;</span><span class="n">PARAMETER_TYPE</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// note the &quot;false&quot; specifies that it is statically allocated, so no &quot;malloc&quot; required</span>
<span class="k">using</span><span class="w"> </span><span class="n">NEW_SEQUENTIAL_CAPABILITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SEQUENTIAL</span><span class="o">::</span><span class="n">CHANGE_CAPABILITY</span><span class="o">&lt;</span><span class="n">NEW_CAPABILITY</span><span class="o">&gt;</span><span class="p">;</span>
<br/></pre></div>
</div>
</div>
<p>Lets also say we want to increase the <code class="docutils literal notranslate"><span class="pre">BATCH_SIZE</span></code> for training:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[41]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="n">TI</span><span class="w"> </span><span class="n">NEW_BATCH_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>

<span class="k">using</span><span class="w"> </span><span class="n">NEW_SEQUENTIAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NEW_SEQUENTIAL_CAPABILITY</span><span class="o">::</span><span class="n">CHANGE_BATCH_SIZE</span><span class="o">&lt;</span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="n">NEW_BATCH_SIZE</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">NEW_SEQUENTIAL</span><span class="w"> </span><span class="n">new_sequential</span><span class="p">;</span>
<span class="n">NEW_SEQUENTIAL</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="w"> </span><span class="n">new_sequential_buffer</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;false&quot; again specifies a static buffer, no &quot;malloc&quot; required</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">sequential</span><span class="p">,</span><span class="w"> </span><span class="n">new_sequential</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Models and layers support smaller batch sizes than specified in the <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> call (as long as the buffer matches the batch size), hence we can check if it still gives the same result:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[42]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">evaluate</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">new_sequential</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="n">new_sequential_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
dim[0] = 0:
   2.216075e-01   1.333383e-01   1.274712e-02  -2.575321e-01

</pre></div></div>
</div>
<p>Now for the backward pass we need to record intermediate values, which are thrown away for efficiency in the <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> call. Hence we call the <code class="docutils literal notranslate"><span class="pre">forward</span></code> function</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[43]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">rlt</span><span class="o">::</span><span class="n">tensor</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">NEW_SEQUENTIAL</span><span class="o">::</span><span class="n">INPUT_SHAPE</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">new_input</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">randn</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">new_input</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>

<span class="n">rlt</span><span class="o">::</span><span class="n">forward</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">new_sequential</span><span class="p">,</span><span class="w"> </span><span class="n">new_input</span><span class="p">,</span><span class="w"> </span><span class="n">new_sequential_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>After the forward pass we can simulate some loss function by generating a random <span class="math notranslate nohighlight">\(\frac{\mathrm{d}L}{\mathrm{d}\;\text{output}}\)</span> and calculating the gradient wrt. the parameters:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[44]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">rlt</span><span class="o">::</span><span class="n">tensor</span><span class="o">::</span><span class="n">Specification</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TI</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">NEW_SEQUENTIAL</span><span class="o">::</span><span class="n">OUTPUT_SHAPE</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">new_d_output</span><span class="p">;</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">randn</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">new_d_output</span><span class="p">,</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>

<span class="n">rlt</span><span class="o">::</span><span class="n">zero_gradient</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">new_sequential</span><span class="p">);</span>
<span class="n">rlt</span><span class="o">::</span><span class="n">backward</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">new_sequential</span><span class="p">,</span><span class="w"> </span><span class="n">new_input</span><span class="p">,</span><span class="w"> </span><span class="n">new_d_output</span><span class="p">,</span><span class="w"> </span><span class="n">new_sequential_buffer</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[45]:
</pre></div>
</div>
<div class="input_area highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rlt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">new_sequential</span><span class="p">.</span><span class="n">content</span><span class="p">.</span><span class="n">weights</span><span class="p">.</span><span class="n">gradient</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
    0.257953     0.314552    -0.433964    -0.177880     0.359262
   -0.187324     0.540005    -0.405738    -0.105435     0.005223
   -1.100354     0.812718    -0.122218    -0.695884    -0.693243
   -0.279631     0.184959    -0.046335    -0.256824     0.069136
    0.424668    -0.247924    -0.402325     0.470506     0.445497
    0.073845     0.257173    -0.276413    -0.418117     0.609768
   -0.077138    -0.145775     0.574608     0.249916    -0.175546
   -0.505004     0.426311    -0.045607    -0.612155    -0.297598
   -0.250628     0.001032     0.089749     0.502791    -0.259028
    0.039623    -0.304243     0.358738     0.002726     0.028491
   -0.021576     0.038357     0.361321    -0.204293     0.341441
   -0.536234     0.010839     0.111775    -0.395779    -0.134533
    0.055270     0.028513     0.068843    -0.504675     0.121817
    0.276629    -0.143951     0.407516    -0.567604     0.365112
   -0.572607    -0.064859    -0.078383    -0.411069    -0.503144
   -0.262249     0.001710     0.181928    -0.012536     0.187227
    0.470755    -0.674596     0.692451     0.698694     0.463525
    0.793571     0.159827     0.389859     0.822169    -0.297239
    0.199279     0.314133    -0.589019    -0.188222     0.649840
   -0.017297    -0.286261     0.407374     0.007105     0.313376
    0.172832     0.162735     0.021157     0.228161    -0.081224
    0.408129     0.325322     0.154821     0.223985     0.024119
   -0.373206     0.009890     0.250110     0.083007    -0.164883
    0.143843    -0.256574     0.083730     0.694237     0.250891
    0.029598     0.193670    -0.135681     0.344866     0.511517
    0.307294    -0.049818    -0.084429     0.042628    -0.387741
   -0.163530    -0.054293     0.070724    -0.417164     0.087039
    0.131608    -0.096381    -0.257672    -0.506925     0.119585
   -0.619304     0.274425    -0.408675     0.195700    -0.364539
    0.577951    -0.166629     0.236388     0.461357     0.288696
    0.483178    -0.322789     0.219588     0.227474     0.331068
    0.383174    -0.138118    -0.205649     0.374215     0.287233
</pre></div></div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="04-CPU%20Acceleration.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">CPU Acceleration</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="02-Multiple%20Dispatch.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Multiple Dispatch</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Deep Learning</a><ul>
<li><a class="reference internal" href="#Multilayer-Perceptron-(MLP)">Multilayer Perceptron (MLP)</a></li>
<li><a class="reference internal" href="#Sequential">Sequential</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/furo.js?v=32e29ea5"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>